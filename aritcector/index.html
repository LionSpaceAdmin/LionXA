<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Xagent — שיקוף ארכיטקטורה (מנותק)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { background-color: #0b1220; color: #e5e7eb; }
    canvas { cursor: grab; }
    canvas.grabbing { cursor: grabbing; }
    .tooltip { position: fixed; background: rgba(255,255,255,0.95); color:#0b1220; padding:8px 12px; border-radius:8px; font-size:14px; pointer-events:none; display:none; max-width:320px; }
    .card { background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.12); border-radius: 12px; }
  </style>
</head>
<body class="h-screen flex flex-col">
  <header class="flex-shrink-0 bg-slate-900/80 backdrop-blur border-b border-slate-800">
    <div class="max-w-7xl mx-auto px-4 py-3 flex items-center gap-4">
      <div class="text-xl font-semibold">Xagent — שיקוף ארכיטקטורה</div>
      <div id="status" class="ml-auto text-sm text-slate-300 flex items-center gap-2">
        <span class="inline-flex h-2 w-2 rounded-full bg-blue-400"></span>
        <span>סטטי (מנותק, ללא שרת)</span>
      </div>
    </div>
  </header>

  <main class="flex-1 grid grid-cols-1 lg:grid-cols-3 gap-4 p-4 max-w-7xl mx-auto w-full">
    <section class="card lg:col-span-2 p-0 relative overflow-hidden">
      <div class="px-4 py-2 border-b border-slate-800 flex items-center justify-between">
        <div class="font-medium">תרשים זרימה כללי</div>
        <div class="text-xs text-slate-400">גרור/התקרב לתרשים</div>
      </div>
      <div class="relative h-[540px]">
        <canvas id="flowCanvas" class="absolute top-0 left-0 w-full h-full"></canvas>
        <div id="tooltip" class="tooltip"></div>
        <div class="absolute top-3 left-3 bg-slate-900/80 border border-slate-700 text-slate-200 px-3 py-1 rounded-md text-sm shadow">
          מצב: <span class="font-semibold text-blue-300">סטטי (ללא שרת)</span>
        </div>
      </div>
    </section>

    <aside class="card p-4 flex flex-col gap-4">
      <div class="flex items-center justify-between">
        <div class="font-medium">סטטוס הפרויקט</div>
        <div class="flex items-center gap-2">
          <button id="btn-refresh" class="px-2 py-1 text-xs rounded bg-slate-800 hover:bg-slate-700 border border-slate-700">רענון נתונים</button>
          <label class="text-xs inline-flex items-center gap-1 cursor-pointer select-none">
            <input id="auto-refresh" type="checkbox" class="accent-blue-400" /> רענון אוטומטי
          </label>
        </div>
      </div>

      <div id="meta" class="grid grid-cols-2 gap-2 text-sm">
        <div class="p-3 rounded bg-slate-800/40 border border-slate-700">
          <div class="text-slate-400">קבצים</div>
          <div id="stat-files" class="text-lg font-semibold">—</div>
        </div>
        <div class="p-3 rounded bg-slate-800/40 border border-slate-700">
          <div class="text-slate-400">שורות</div>
          <div id="stat-lines" class="text-lg font-semibold">—</div>
        </div>
        <div class="p-3 rounded bg-slate-800/40 border border-slate-700">
          <div class="text-slate-400">TypeScript</div>
          <div id="stat-ts" class="text-lg font-semibold">—</div>
        </div>
        <div class="p-3 rounded bg-slate-800/40 border border-slate-700">
          <div class="text-slate-400">עודכן</div>
          <div id="stat-updated" class="text-lg font-semibold">—</div>
        </div>
      </div>

      <div class="font-medium mt-2">מודולים עיקריים</div>
      <ul id="modules" class="text-sm space-y-1 max-h-60 overflow-auto pr-1">
        <!-- ממולא מנתוני הארכיטקטורה -->
      </ul>
    </aside>
  </main>

  <!-- נתוני ארכיטקטורה נוצרים ע"י הסקריפט ומוזרקים כגלובלי -->
  <script src="./architecture.data.js"></script>

  <script>
    const statusEl = document.getElementById('status');
    // ---- זרימה גרפית סטטית (כמו ב-flowchart), ללא תלות בשרת ----
    const canvas = document.getElementById('flowCanvas');
    const tooltip = document.getElementById('tooltip');
    const ctx = canvas.getContext('2d');

    // גרף זרימה קבוע, משקף את מהלך העבודה של הסוכן
    const nodes = [
      { id: 1, x: 600, y: 50, w: 180, h: 60, label: 'התחלה', type: 'start', desc: 'תהליך הסוכן מתחיל לפעול.' },
      { id: 2, x: 350, y: 150, w: 200, h: 70, label: 'אתחול דפדפן (Playwright)', type: 'process', desc: 'סשן כרום מתמיד עם פרופיל משתמש.' },
      { id: 3, x: 850, y: 150, w: 200, h: 70, label: 'דאשבורד (אופציונלי)', type: 'process', desc: 'שרת Express+Socket.IO לשידור סטטוס (לא חובה).' },
      { id: 4, x: 350, y: 260, w: 200, h: 70, label: 'טעינת רשימת X', type: 'process', desc: 'נווט לרשימת המעקב.' },
      { id: 5, x: 600, y: 370, w: 220, h: 80, label: 'סריקת ציוצים', type: 'process', desc: 'איסוף ציוצים מהדף.' },
      { id: 6, x: 600, y: 500, w: 220, h: 80, label: 'לולאת עיבוד', type: 'loop', desc: 'מעבד כל ציוץ חדש.' },
      { id: 7, x: 600, y: 630, w: 220, h: 80, label: 'חדש?', type: 'decision', desc: 'בדיקה מול זיכרון מקומי.' },
      { id: 8, x: 350, y: 760, w: 220, h: 80, label: 'פרופיל קיים?', type: 'decision', desc: 'בדיקת פרופיל למגיב.' },
      { id: 9, x: 350, y: 890, w: 220, h: 80, label: 'יצירת פרומפט', type: 'process', desc: 'שילוב תוכן+הנחיות.' },
      { id: 10, x: 350, y: 1020, w: 220, h: 80, label: 'קריאת Gemini', type: 'io', desc: 'שליחת פרומפט וקבלת תשובה.' },
      { id: 11, x: 600, y: 1020, w: 220, h: 80, label: 'תשובה?', type: 'decision', desc: 'אימות תשובה.' },
      { id: 12, x: 600, y: 1150, w: 220, h: 80, label: 'פרסום תגובה', type: 'process', desc: 'הדמיית הקלדה ולחיצה על "הגב".' },
      { id: 13, x: 600, y: 1280, w: 220, h: 80, label: 'עדכון זיכרון', type: 'process', desc: 'סימון הציוץ כמעובד.' },
      { id: 14, x: 600, y: 1410, w: 220, h: 80, label: 'המתנה', type: 'process', desc: 'המתנה לסריקה הבאה.' },
      { id: 15, x: 1100, y: 630, w: 200, h: 70, label: 'לוגים', type: 'io', desc: 'רישום אירועים.' },
      { id: 16, x: 1100, y: 300, w: 200, h: 70, label: 'UI דאשבורד', type: 'output', desc: 'מציג נתונים אם שרת קיים.' }
    ];
    const edges = [
      { from: 1, to: 2 }, { from: 1, to: 3, label: 'אופציונלי' }, { from: 2, to: 4 }, { from: 4, to: 5 },
      { from: 5, to: 6 }, { from: 6, to: 7 }, { from: 7, to: 8, label: 'כן' }, { from: 7, to: 6, side: 'right', label: 'לא' },
      { from: 8, to: 9, label: 'כן' }, { from: 8, to: 6, side: 'left', label: 'לא' }, { from: 9, to: 10 }, { from: 10, to: 11 },
      { from: 11, to: 12, label: 'כן' }, { from: 11, to: 6, side: 'right', label: 'לא' }, { from: 12, to: 13, label: 'הצלחה' },
      { from: 12, to: 15, label: 'לוג' }, { from: 13, to: 14 }, { from: 14, to: 4, side: 'left', label: 'חזרה' }, { from: 15, to: 16 }
    ];

    const NODE_COLORS = { process:'#2563eb', start:'#16a34a', decision:'#f97316', loop:'#9333ea', io:'#db2777', output:'#4b5563', default:'#3b82f6' };
    let transform = { x: 0, y: 0, scale: 0.8 };
    let isPanning = false, isDragging = false, dragStart = {x:0,y:0}, draggedNode = null, hoveredNode = null;

    function resizeCanvas() {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = canvas.offsetWidth * dpr;
      canvas.height = canvas.offsetHeight * dpr;
      ctx.setTransform(1,0,0,1,0,0);
      ctx.scale(dpr, dpr);
      draw();
    }

    function draw() {
      ctx.save();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.translate(transform.x, transform.y);
      ctx.scale(transform.scale, transform.scale);
      drawGrid();
      drawEdges();
      drawNodes();
      ctx.restore();
    }

    function drawGrid() {
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      ctx.lineWidth = 1;
      const gridSize = 50;
      const scaled = gridSize * transform.scale;
      const offsetX = transform.x % scaled;
      const offsetY = transform.y % scaled;
      for (let x = offsetX/transform.scale; x < canvas.offsetWidth/transform.scale; x += gridSize) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.offsetHeight/transform.scale); ctx.stroke(); }
      for (let y = offsetY/transform.scale; y < canvas.offsetHeight/transform.scale; y += gridSize) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.offsetWidth/transform.scale, y); ctx.stroke(); }
    }

    function drawNodes() {
      nodes.forEach(node => {
        ctx.save();
        ctx.fillStyle = NODE_COLORS[node.type] || NODE_COLORS.default;
        ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 10; ctx.shadowOffsetX = 5; ctx.shadowOffsetY = 5;
        const x = node.x - node.w/2, y = node.y - node.h/2;
        ctx.beginPath();
        if (ctx.roundRect) ctx.roundRect(x, y, node.w, node.h, 10); else { ctx.rect(x, y, node.w, node.h); }
        ctx.fill();
        if (hoveredNode && hoveredNode.id === node.id) { ctx.strokeStyle = '#facc15'; ctx.lineWidth = 3; ctx.stroke(); }
        ctx.restore();
        ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.font = 'bold 16px Arial';
        ctx.fillText(node.label, node.x, node.y);
      });
    }

    function drawEdges() {
      edges.forEach(edge => {
        const from = nodes.find(n => n.id === edge.from), to = nodes.find(n => n.id === edge.to);
        if (!from || !to) return;
        ctx.save(); ctx.strokeStyle = '#6b7280'; ctx.lineWidth = 2.5; ctx.beginPath();
        let startX, startY, endX, endY;
        if (edge.side === 'right') {
          startX = from.x + from.w/2; startY = from.y; endX = to.x + to.w/2; endY = to.y;
          ctx.moveTo(startX, startY); ctx.lineTo(startX+40, startY); ctx.lineTo(endX+40, endY); ctx.lineTo(endX, endY);
        } else if (edge.side === 'left') {
          startX = from.x - from.w/2; startY = from.y; endX = to.x - to.w/2; endY = to.y;
          ctx.moveTo(startX, startY); ctx.lineTo(startX-40, startY); ctx.lineTo(endX-40, endY); ctx.lineTo(endX, endY);
        } else {
          const vertical = Math.abs(from.x - to.x) < 50;
          if (vertical) { startX = from.x; startY = from.y + from.h/2; endX = to.x; endY = to.y - to.h/2; }
          else { startX = from.x < to.x ? from.x + from.w/2 : from.x - from.w/2; startY = from.y; endX = from.x < to.x ? to.x - to.w/2 : to.x + to.w/2; endY = to.y; }
          ctx.moveTo(startX, startY);
          if (vertical) ctx.bezierCurveTo(startX, startY+50, endX, endY-50, endX, endY);
          else ctx.bezierCurveTo(startX+80, startY, endX-80, endY, endX, endY);
        }
        ctx.stroke();
        // Arrow
        const angle = Math.atan2(endY - (startY + (endY-startY)*0.9), endX - (startX + (endX-startX)*0.9));
        ctx.fillStyle = '#6b7280'; ctx.translate(endX, endY); ctx.rotate(angle);
        ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-10,5); ctx.lineTo(-10,-5); ctx.closePath(); ctx.fill();
        ctx.restore();
        // Label
        if (edge.label) { ctx.save(); ctx.fillStyle='#d1d5db'; ctx.font='14px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle'; const midX = startX+(endX-startX)/2; const midY = startY+(endY-startY)/2; if(edge.side==='right') ctx.fillText(edge.label, midX+45, midY); else if(edge.side==='left') ctx.fillText(edge.label, midX-45, midY); else ctx.fillText(edge.label, midX, midY-15); ctx.restore(); }
      });
    }

    function getMousePos(e){ const r = canvas.getBoundingClientRect(); return { x: e.clientX - r.left, y: e.clientY - r.top }; }
    function getTransformedPos(e){ const m = getMousePos(e); return { x: (m.x - transform.x)/transform.scale, y: (m.y - transform.y)/transform.scale }; }
    function getNodeAt(pos){ for(let i=nodes.length-1; i>=0; i--){ const n = nodes[i]; if (pos.x>=n.x-n.w/2 && pos.x<=n.x+n.w/2 && pos.y>=n.y-n.h/2 && pos.y<=n.y+n.h/2) return n; } return null; }

    canvas.addEventListener('mousedown', e => { const p = getTransformedPos(e); draggedNode = getNodeAt(p); if (draggedNode){ isDragging = true; dragStart.x = p.x - draggedNode.x; dragStart.y = p.y - draggedNode.y; } else { isPanning = true; dragStart.x = e.clientX - transform.x; dragStart.y = e.clientY - transform.y; canvas.classList.add('grabbing'); } });
    canvas.addEventListener('mousemove', e => { const p = getTransformedPos(e); if (isDragging && draggedNode){ draggedNode.x = p.x - dragStart.x; draggedNode.y = p.y - dragStart.y; draw(); } else if (isPanning){ transform.x = e.clientX - dragStart.x; transform.y = e.clientY - dragStart.y; draw(); }
      const cur = getNodeAt(p); if (cur){ if (hoveredNode?.id !== cur.id){ hoveredNode = cur; draw(); } tooltip.style.display='block'; tooltip.style.left = `${e.clientX+15}px`; tooltip.style.top = `${e.clientY}px`; tooltip.innerHTML = `<div class="font-bold mb-1">${cur.label}</div><div>${cur.desc||''}</div>`; } else { if (hoveredNode){ hoveredNode=null; draw(); } tooltip.style.display='none'; } });
    canvas.addEventListener('mouseup', ()=>{ isDragging=false; isPanning=false; draggedNode=null; canvas.classList.remove('grabbing'); });
    canvas.addEventListener('mouseleave', ()=>{ isDragging=false; isPanning=false; draggedNode=null; hoveredNode=null; tooltip.style.display='none'; canvas.classList.remove('grabbing'); draw(); });
    canvas.addEventListener('wheel', e=>{ e.preventDefault(); const scaleAmount = 1.1; const m = getMousePos(e); const wx = (m.x - transform.x)/transform.scale; const wy = (m.y - transform.y)/transform.scale; const ns = e.deltaY<0 ? transform.scale*scaleAmount : transform.scale/amount; transform.scale = Math.max(0.2, Math.min(ns, 3)); transform.x = m.x - wx*transform.scale; transform.y = m.y - wy*transform.scale; draw(); });
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // ---- טעינת נתוני ארכיטקטורה (ללא שרת) ----
    function applyArchData(data){
      try {
        document.getElementById('stat-files').textContent = data?.stats?.totalFiles ?? '—';
        document.getElementById('stat-lines').textContent = data?.stats?.totalLines ?? '—';
        document.getElementById('stat-ts').textContent = data?.stats?.tsFiles ?? '—';
        document.getElementById('stat-updated').textContent = data?.meta?.generatedAt ? new Date(data.meta.generatedAt).toLocaleString() : '—';
        const modulesEl = document.getElementById('modules');
        modulesEl.innerHTML = '';
        const mods = (data?.modules ?? []).slice().sort((a,b)=> (b.lines||0)-(a.lines||0)).slice(0, 14);
        if (mods.length === 0) {
          (data?.sections ?? []).forEach(sec => {
            const li = document.createElement('li');
            li.innerHTML = `<div class="font-semibold text-slate-200">${sec.title}</div><div class="text-slate-400 text-xs">${sec.description||''}</div>`;
            modulesEl.appendChild(li);
          });
        } else {
          mods.forEach(m => {
            const li = document.createElement('li');
            const imports = (m.imports||[]).filter(x=>x.startsWith('src/')).length;
            li.className = 'p-2 rounded bg-slate-800/40 border border-slate-700';
            li.innerHTML = `<div class="font-mono text-slate-200">${m.path}</div><div class="text-slate-400 text-xs">שורות: ${m.lines || 0} · יבואים פנימיים: ${imports}</div>`;
            modulesEl.appendChild(li);
          });
        }
      } catch (e) { console.warn('Failed applying data', e); }
    }

    function loadDataOnce(cb){
      const prev = document.getElementById('arch-data-script');
      if (prev) prev.remove();
      (window).XAGENT_ARCH = (window).XAGENT_ARCH || undefined;
      const s = document.createElement('script');
      s.id = 'arch-data-script';
      s.src = `./architecture.data.js?_=${Date.now()}`;
      s.onload = () => { try { cb && cb((window).XAGENT_ARCH); } catch(e){} };
      s.onerror = () => { console.warn('לא נמצא architecture.data.js — משתמש בברירת מחדל'); cb && cb(defaultData()); };
      document.body.appendChild(s);
    }

    function defaultData(){
      return {
        meta: { generatedAt: new Date().toISOString() },
        stats: { totalFiles: 0, totalLines: 0, tsFiles: 0 },
        sections: [
          { id:'app', title:'src/app (Next.js)', description:'דפים ו־layout של ה־UI' },
          { id:'components', title:'src/components/dashboard', description:'רכיבי UI (MetricCard, Header, Sidebar)' },
          { id:'dashboard', title:'src/dashboard.ts', description:'שרת Express+Socket.IO לשידור אירועים' },
          { id:'agent', title:'src/watchList.ts', description:'לולאת הסוכן (Playwright + Gemini)' },
          { id:'browser', title:'src/browser.ts', description:'ניהול סשן כרום מתמיד' },
          { id:'gemini', title:'src/gemini.ts', description:'לקוח Google Generative AI' }
        ]
      };
    }

    // אתחול ראשון
    // Live mode via Next API if served over HTTP
    function tryLiveOnce() {
        const candidates = [
          `/api/architecture?ts=${Date.now()}`,
          `http://127.0.0.1:3003/api/architecture?ts=${Date.now()}`,
          `http://127.0.0.1:3001/api/architecture?ts=${Date.now()}`
        ];
        const tryFetch = (i) => {
          if (i >= candidates.length) return Promise.reject('no-source');
          return fetch(candidates[i], { cache: 'no-store' })
            .then(r => r.ok ? r.json() : Promise.reject(r.status))
            .catch(() => tryFetch(i+1));
        };
        return tryFetch(0)
          .then(r => r.ok ? r.json() : Promise.reject(r.status))
          .then(data => {
            applyArchData(data);
            if (statusEl) statusEl.innerHTML = '<span class="inline-flex h-2 w-2 rounded-full bg-green-400"></span><span>חי (שרת זמין)</span>';
            return true;
          })
          .catch(() => false);
    }

    (async () => {
      const liveOK = await tryLiveOnce();
      if (!liveOK) {
        applyArchData((window).XAGENT_ARCH || defaultData());
      }
    })();

    // ריענון ידני/אוטומטי
    document.getElementById('btn-refresh').addEventListener('click', async () => {
      const liveOK = await tryLiveOnce();
      if (!liveOK) loadDataOnce(applyArchData);
    });
    const auto = document.getElementById('auto-refresh');
    let timer = null;
    const shouldAuto = new URLSearchParams(location.search).has('serverWindowId');
    if (shouldAuto) { auto.checked = true; }
    function startAuto(){
      if (timer) clearInterval(timer);
      timer = setInterval(async () => {
        const liveOK = await tryLiveOnce();
        if (!liveOK) loadDataOnce(applyArchData);
      }, 5000);
    }
    auto.addEventListener('change', ()=>{
      if (auto.checked){ startAuto(); }
      else if (timer){ clearInterval(timer); timer = null; }
    });
    if (auto.checked) startAuto();
  </script>
</body>
</html>
